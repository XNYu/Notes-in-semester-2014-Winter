<!DOCTYPE html>
<html>
<head>
<title>11 数据挖掘</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #000;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 20px;
}

h4 {
  font-size: 18px;
}

h5 {
  font-size: 16px;
}

h6 {
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #000;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #000;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>11 Data Mining</h1>
<p>数据库及数据仓库中存储有大量数据。充分开发、利用这些数据资源是一项重要工作。</p>
<h5>数据资源的利用方式</h5>
<ul>
<li>数据资源的查询服务<br />
可以针对原子层，也可以针对聚集数据进行查询</li>
<li>数据资源的演绎  <br />
应当提供定制化的查询方式<br />
查询结果是稳定的
任何可能有助于分析应用的工具都可能会被使用<br />
典型应用：专家系统<br />
OLAP并非简单的输入/输出过程，存在相关的交互，由人来判断下一步要做什么</li>
<li>数据资源的归纳<br />
<strong><em>数据挖掘</em></strong></li>
</ul>
<h5>三种利用方式之间的区别</h5>
<ul>
<li>使用数据挖掘技术可以发现用户未知的信息</li>
<li>使用数据挖掘技术可以寻找到具有普遍意义的知识，并将其应用到其它同类应用中，以帮助用户进行决策</li>
</ul>
<p>前两种利用方式都是一种确定性的计算，而数据挖掘以接近人的方式做推断</p>
<h2>一、数据挖掘</h2>
<h3>1.什么是数据挖掘</h3>
<p>Data Mining</p>
<ul>
<li>又被称为<strong>数据库中的知识发现</strong>（KDD）<br />
机器学习和数据分析的理论及实践是数据挖掘研究的基础<br />
商业应用前景是数据挖掘研究工作的巨大推动力</li>
<li>传统的数据库查询和统计只能提供想要的信息，而数据挖掘技术可以发现没有意识到的未知信息</li>
</ul>
<h3>2.具体定义</h3>
<h4>定义一</h4>
<p>对数据库中<strong>蕴含的、未知的、非平凡的、有潜在应用价值的模式（规则）</strong>的提取</p>
<ul>
<li>非平凡的<br />
不能通过固定的计算方式得到</li>
<li>有潜在应用价值的<br />
虽然当前规则或模式是正确的，但这个模式在<em>目前技术条件</em>下无法用以改善生活、学习、生产，此规则也无效</li>
<li>模式<br />
可能以规则的方式进行表达</li>
</ul>
<h4>定义二</h4>
<p>从大型数据库的数据中提取人们<strong>感兴趣的知识</strong>，这些知识是<strong>隐含的、事先未知的潜在有用信息</strong></p>
<ul>
<li>感兴趣<br />
有用的</li>
</ul>
<h3>3.数据挖掘的三个因素</h3>
<ul>
<li>
数据挖掘的本源：大量、完整的数据
<ul>
<li>如果数据量不大，当前的挖掘任务未必能得出正确结论</li>
<li>如果不完整，结果可能无法放在更大样本上验证</li>
</ul>
</li>
<li>数据挖掘的结果：知识、规则<br />
由于获取知识相当困难，我们希望得到知识候选，再以人的方式来筛选</li>
<li>结果的隐含性<br />
不是能够得到固定结果的计算<br />
因此需要挖掘的过程</li>
</ul>
<h3>4.数据挖掘的特征</h3>
<ul>
<li>在大量的、完整的数据集中进行数据的挖掘工作</li>
<li>归纳结果应该是具有普遍性意义的规则<br />
在当前数据中得到的结论在更大规模的其它数据上有很大概率也成立</li>
<li>数据挖掘的目的：用归纳出的规律来指导客观世界</li>
</ul>
<h3>5.数据挖掘的基本概念</h3>
<h4>模式</h4>
<ul>
<li>任何用高级语言表达一定逻辑含义的信息都是模式<br />
携带信息，携带判断<br />
<em>无论对错都是模式</em></li>
<li>通常指数据库中数据与数据之间的逻辑关系</li>
</ul>
<h4>知识</h4>
<p>满足用户对客观评价标准（兴趣度/置信度……）和主观评价标准要求的<strong>模式</strong></p>
<ul>
<li>只要与当前分析任务相匹配，客观指标可以任意制定</li>
<li><em>正是由于无法进行主观评价，机器转而提供一些客观标准，从而可以事先排除一些明显的错误</em></li>
</ul>
<h5>置信度</h5>
<p>在某一数据集上，模式成立的程度</p>
<blockquote>
<h6>例：模式R1：在购买面包和黄油的顾客中，大部分的人同时也买了牛奶</h6>
<p>该模式的置信度为：同时购买面包、黄油、牛奶的顾客人数占同时购买面包、黄油的顾客人数的百分比</p>
</blockquote>
<ul>
<li>置信度不是固定的</li>
<li>通过数据挖掘所发现的模式的置信度大小涉及到许多因素<br />
数据的完整性、样本数据的大小、领域知识的支持程度等</li>
<li>没有足够的置信度，模式便不能成为知识<br />
有意义的置信度要在良好的数据集中得到<br />
通常要规定模式的最小置信度，通过此阈值过滤掉一部分被认为并不正确的模式</li>
</ul>
<h5>兴趣度</h5>
<p>在某一数据集上，模式被用户关注的程度</p>
<blockquote>
<h6>例：R1同上</h6>
<p>模式R1的支持度为同时购买面包，黄油和牛奶的顾客人数占总顾客人数的百分比</p>
</blockquote>
<ul>
<li>只有一个模式的兴趣度达到一定程度时，该模式才是有意义的模式<br />
才能引起用户的注意，有助于用户的决策制定过程<br />
因此数据挖掘过程中也要规定模式的最小兴趣度，以淘汰在极少情况下才会出现的模式</li>
</ul>
<h4>非平凡性</h4>
<h5>平凡知识</h5>
<p>能够以确定的计算过程提取的模式</p>
<p><em>平凡的知识不是数据挖掘的目标</em>，因为这样的知识已经成为<strong>常识</strong></p>
<p>在数据挖掘中，知识的发现过程都应具有某种<em>不确定性</em>和一定的<em>自由度</em>，即要发现不平凡的知识</p>
<h4>有效性</h4>
<p>知识的发现过程必须能够有效地在计算机上实现</p>
<ul>
<li>时间有效性</li>
<li>空间有效性</li>
</ul>
<p>这限制了太复杂的相关算法是不能被应用于数据挖掘的<br />
<em>但往往可以应用于其它领域，如</em><strong><em>人工智能</em></strong></p>
<h3>6.数据挖掘的特点</h3>
<ul>
<li>数据挖掘要处理大量的数据</li>
<li>由于用户不能形成精确的查询要求，因此要依靠数据挖掘技术为用户寻找他可能感兴趣的东西<br />
希望用户尽可能少的介入</li>
<li>在数据挖掘过程中，规则的发现基于统计规律<br />
发现的规则不必适用于所有数据</li>
<li>数据挖掘所发现的规则是动态的，只反映了当前状态的数据集合具有的规则<br />
数据挖掘以数据为导向，根据数据集的变化需要重新进行挖掘，以期望挖掘到新的规则<br />
<em>采用相同的算法，即使基于相同的数据也可能得到不同的结论</em></li>
</ul>
<h3>7.数据挖掘的相关领域</h3>
<ul>
<li>数据库系统<br />
数据源相关</li>
<li>统计学<br />
概率的讨论</li>
<li>机器学习<br />
算法的移植</li>
<li>信息科学<br />
定性、定量地计算需要的信息量，从而指导数据的挖掘</li>
<li>可视化<br />
挖掘过程的可视化、规则展现的可视化</li>
<li>其它学科<br />
多媒体、图像处理……</li>
</ul>
<p>实际上数据挖掘是一门交叉型学科</p>
<h2>二、数据仓库与数据挖掘</h2>
<h3>1.基于数据库和基于数据仓库的数据挖掘</h3>
<ul>
<li>数据挖掘建立在数据库的基础之上<br />
数据挖掘只是其中的一个部分，在此之前需要大量的数据查询和预处理</li>
<li>产生数据仓库技术后<br />
由于数据仓库中的数据都是经过抽取、整理和预处理后的综合数据，因而数据挖掘工作可以在数据仓库上直接运行<br />
任务相对来说会简单很多，<em>但并不代表数据挖掘可以无缝地架设在数据仓库之上</em><br />
取决于数据仓库的数据结构与数据挖掘需要的数据结构之间的差距，不过这种转换只涉及到形式层面</li>
</ul>
<h3>2.利用数据库系统进行数据挖掘的缺点</h3>
<h4>动态数据</h4>
<ul>
<li>大多数数据库的基本特点是内容将经常变化  </li>
<li>在线系统中，必须采用预警机制来保证数据库中的这些变化不会导致错误的数据挖掘结果</li>
</ul>
<h4>噪声和不确定性</h4>
<ul>
<li>噪声数据<br />
数据库中的错误数据和异常现象</li>
<li>不确定性<br />
发现的模式可能只在一部分数据上有效</li>
</ul>
<h4>冗余信息</h4>
<ul>
<li>同一数据在操作型数据环境中的多处出现<br />
并不针对单个数据库，多个数据库拼合就可能发生此问题</li>
<li>
有时会误导知识的发现过程
<ul>
<li>
可能会夸大某个模式的置信度
<blockquote>
<p>(A+B)/A<strong>&lt;</strong>(A+B)+n/A+n</p>
</blockquote>
</li>
<li>
可能会低估某个模式的兴趣度
<blockquote>
<p>(A+B)/A<strong>&gt;</strong>(A+B)/A+n</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4>不完整数据</h4>
<h4>稀疏数据</h4>
<h2>三、数据挖掘的步骤</h2>
<h3>1.数据挖掘技术在决策支持过程中的地位</h3>
<p>见ppt第25页</p>
<ul>
<li>问题域<br />
对当前需要回答的问题的大方向要有所了解</li>
<li>选择目标数据集<br />
哪些数据与当前的问题域相关<br />
数据仓库中包含大量分析型数据，而可能与当前问题没有直接关联<br />
增加处理、传输的开销，可能产生误导，处理能力也可能会有所限制<br />
采用人配合计算机以半自动的方式筛去部分数据</li>
<li>数据预处理<br />
转成当前数据挖掘所需要的样式</li>
<li><strong><em>数据挖掘</em></strong><br />
调用算法，得到模式的集合，精确地回答需要的问题</li>
<li>模式评价与理解<br />
可能会产生某些无法理解的结果或带来的误差<br />
如果满足不了用户的需要，向前回退到任意一个环节重新开始</li>
<li>决策支持应用<br />
交给实际与此模式相关的部门改进业务</li>
</ul>
<p>数据挖掘是其中重要一环</p>
<h3>2.数据集成</h3>
<ul>
<li>
数据挖掘的基础是数据，因此挖掘前必须进行数据集成
<ul>
<li>从各类数据系统中提取挖掘所需的统一数据类型，建立一致的数据视图</li>
<li>做数据加载，从而形成挖掘的数据挖掘的基础</li>
</ul>
</li>
</ul>
<p>目前一般用数据仓库实现数据集成</p>
<h4>通常需要做的预处理</h4>
<h5>数据清理</h5>
<ul>
<li>填补丢失的数据</li>
<li>清除噪声数据</li>
<li>修正数据的不一致性</li>
</ul>
<h5>数据集成</h5>
<h5>数据转换</h5>
<p>我们收集到的数据有时并不一定适合数据挖掘的需要，如已有的挖掘方法可能无法处理这些数据，存在一些不规则的数据，或者数据本身不够充分等，因此需要对收集到的数据进行转换</p>
<p><em>如果没有数据仓库，或者当前任务没有重复可能，可以建立一个小规模的数据集市，以期待后续能够自底向上地创建数据仓库</em></p>
<h3>3.数据规约</h3>
<ul>
<li>用于数据挖掘的数据量非常巨大<br />
数据规约可以减低数据量，提高数据挖掘操作的性能<br />
如果在规约后的数据集上挖掘可以获得与原来一样或<em>几乎</em>一样的挖掘结果，就可以考虑采用一定的规约技术</li>
</ul>
<h4>常见的数据规约技术</h4>
<ul>
<li>数据立方体计算</li>
<li>
挖掘范围的选择  

<ul>
<li>在不影响挖掘结果的前提下，尽可能地选取那些与挖掘操作有关的属性集<br />
去除明显无关的因素，或由于法规、风俗等原因，即使有相应的分析结果也无法应用的</li>
<li>时间范围或备份内容上的选择</li>
</ul>
</li>
<li>数据压缩<br />
减低数据的规模，节省存储空间开销和数据通讯开销<br />
如果采用的数据挖掘算法不需要解压就可直接对压缩数据进行挖掘，数据压缩技术将非常有用</li>
<li>离散化处理<br />
将属性值的连续区域划分为若干个区域，用每个区域的标识代替原来的值，以减低该属性上属性值的个数<br />
也可利用这种数据规约技术来自动地建立该属性的概念层次树</li>
</ul>
<h3>4.挖掘、评价</h3>
<p>略</p>
<h3>5.表示</h3>
<p>在计算机中用一定形式表现出来</p>
<ul>
<li>可以包括文字、图形、表格、图标等可视化形式</li>
<li>也可同时用内部结构形式将结果写回数据仓库，供日后进一步分析</li>
</ul>
<h2>四、常用的数据挖掘方法</h2>
<p>目前常用的数据挖掘方法大多属于数学统计方法或人工智能中的机器学习算法，以及人工神经网络/遗传算法等</p>
<h3>1.特征规则挖掘</h3>
<h4>特征规则</h4>
<ul>
<li>常见的知识形式，它用于描述一类数据对象的普遍特征，是普化知识的一种<br />
特征规则是基于概率的知识</li>
<li>特征规则的数据挖掘方法有<strong>面向属性规约方法</strong>和<strong>数据立方方法</strong></li>
</ul>
<h4>面向属性规约方法</h4>
<ul>
<li>常用的特征规则的挖掘方法<br />
通过对属性值间概念的层次结构进行规约，以获得相关数据的概括性知识</li>
<li>在实际情况中，许多属性都可以进行数据归类，形成概念汇聚点<br />
这些概念依抽象程度的不同可构成描述它们层次结构的<strong>概念层次树</strong><br />
根据概念层次树可以对供挖掘用的数据进行预处理，以生成一个适合于进行数据挖掘工作的数据集<br />
<em>因此“面向属性”的数据规约过程实际上是为进行数据挖掘工作而进行的数据预处理</em></li>
</ul>
<h5>概念层次树</h5>
<p>某属性值所具有的从具体的概念值到概念类的层次关系树</p>
<ul>
<li>一般由用户提供，或者从领域知识中得到相关属性的概念层次树</li>
<li>也可以通过多属性体系结构自动构建</li>
</ul>
<h5>规约</h5>
<p>用概念层次树上高层的属性值去替代低层的属性值<br />
又称为<strong>概念提升</strong></p>
<h6>规约的目的</h6>
<ul>
<li>规范化一个属性的取值</li>
<li>提高模式的置信度和兴趣度<br />
从而达到知识的阈值</li>
</ul>
<p><em>当前的规约面向的单位是一条元组中的一个属性，而OLAP中讨论的上钻和下钻是针对数据的汇总；实际上，如果良好地定义了OLAP中的某些聚集值，就可以用OLAP实现规约</em></p>
<h5>基本关系表</h5>
<p>待挖掘的原始细节数据，以关系的形式出现，通常来自于准备好的数据库或数据仓库中</p>
<h5>概括关系表</h5>
<p><em>如果通过规约，可以使当前的属性值数量在某一范围内，就如此实施规约；如果无法规约，就将这组属性去除；如果两组属性高度相关，就认为这两组属性冗余，去除其中一组</em></p>
<p>将取值完全相同的元组进行合并，并附带一个COUNT属性，表示其规约了的基本元组数量<br />
<em>如果不需要节约存储空间，不进行合并也可以</em></p>
<h5>面向属性规约过程</h5>
<p>见ppt</p>
<h4>数据立方方法</h4>
<p>如果统计结果（主要是求和）已经预先计算出来存放在多维数据库中，就可以直接从多维数据库中获得所需要的统计结果，从而节省数据规约的时间，提高数据挖掘的效率</p>
<h5>常用的分析方法</h5>
<ul>
<li>数据概括（roll_up，上翻）<br />
将属性值提升到较高的概念层次上</li>
<li>数据细化（roll_down，下翻）<br />
将属性值减低一些层次</li>
</ul>
<h5>特征规则挖掘与OLAP的区别</h5>
<ul>
<li>特征规则挖掘是由参数主导的<strong>自动化</strong>过程，而OLAP是由分析人员主导的<strong>人工</strong>过程</li>
<li>
在特征规则挖掘过程中，算法可以在阈值的指导下：
<ul>
<li>自动决定排除冗余以及和当前挖掘任务无关的属性</li>
<li>自动决定各个属性规约的层次</li>
<li>在对比集的指导下，在挖掘结果中取出与当前挖掘任务关联不大的属性</li>
</ul>
</li>
</ul>
<h4>概念描述：特征与区分</h4>
<ul>
<li>除了使用特征规则挖掘，发现目标集中蕴含的数据特点外，还可以在引入<em>对比集</em>后进行<strong>区分规则挖掘</strong></li>
<li>特征规则挖掘和区分规则挖掘，是描述型数据挖掘的一体两面，共同构成对一个目标集的概念描述</li>
</ul>
<h3>2.关联规则挖掘</h3>
<h4>关联规则</h4>
<ul>
<li>关联规则用于表示事务数据库中诸多属性之间的关联程度</li>
<li>关联规则挖掘则是利用数据库中的大量数据通过关联算法寻找属性间的相关性</li>
<li>
属性在这里被称为<strong>项</strong><br />
若干个属性所构成的属性集被称为一个<strong>项集</strong>
<blockquote>
<h6>例：超级市场</h6>
<p>在购买商品A的客户中有90%的人会同时购买商品B，则可用关联规则表示为：</p>
<pre><code>R1：A-&gt;B
</code></pre>

</blockquote>
</li>
<li>A-&gt;B与B-&gt;A的兴趣度是相同的，但置信度通常不同</li>
<li>
任意组合均构成关联规则<br />
为了发现有意义的关联规则，需要给定两个阈值：<strong>最小兴趣度</strong>和<strong>最小置信度</strong>
<ul>
<li>满足最小置信度和最小兴趣度的规则为<strong>强规则</strong>，否则为<strong>弱规则</strong></li>
<li>关联规则挖掘的实质是<em>在数据库（数据仓库）中寻找强规则</em></li>
</ul>
</li>
</ul>
<h4>Apriori算法</h4>
<h5>基本概念</h5>
<ul>
<li>项<br />
在数据库中出现的属性值，每一个属性值构成一个项</li>
<li>项集<br />
在数据库中出现的属性值的集合</li>
<li>k-项集<br />
由k个项构成的项集</li>
<li>频繁项集<br />
该项集在数据库中出现的频度满足用户规定的最小支持度的要求<br />
即同时含有该项集中的所有属性值的记录数占所有记录数的百分比大于等于用户规定的最小支持度</li>
<li>关联规则一定是在满足用户的最小支持度要求的频繁项集中产生的<br />
关联规则的挖掘过程也就是在数据库中寻找频繁项集的过程<br />
寻找频繁项集过程中，遵循<strong><em>每个频繁项集的任一子集也是一个频繁项集</em></strong></li>
</ul>
<h5>寻找频繁项集的方法</h5>
<blockquote>
<ul>
<li>寻找一阶频繁项集C1<br />
除去非频繁项集，得到L1</li>
<li>从L1生成二阶超集，即候选频繁项集C2<br />
除去非频繁项集，得到L2</li>
<li>从L2生成三阶超集C3<br />
除去暂时不需要考虑的更高阶超集<br />
除去非频繁项集，得到L3</li>
<li>……</li>
</ul>
<p>最后得到的频繁项集是<strong><em>L1、L2、L3……的并</em></strong></p>
</blockquote>
<p>进行关联分析挖掘前，通常希望将数据库中的内容进行整合，这取决于数据集的定义，以及项集的形式</p>
<h5>算法分析</h5>
<ul>
<li>得到的最大频繁项集长度与项的数量处在同一数量级</li>
<li>每求一次超集，就需要扫描一遍项集</li>
</ul>
<h5>生成关联规则</h5>
<blockquote>
<ul>
<li>
<p>针对频繁项集{A,C}可以构造两条规则</p>
<pre><code>R1：A-&gt;C
R2：C-&gt;A
</code></pre>

<p>一阶频繁项集无法构造关联规则，只能得到平凡知识<br />
将每个频繁项集分为左右两部分，穷举即可以得到</p>
</li>
<li>对这些规则分别计算置信度<br />
计算置信度时不需要再扫描数据库</li>
<li>通过预先设定的阈值对关联规则进行过滤</li>
<li>针对生成的关联规则进行一些主观性的解读<br />
剔除已知的关联规则</li>
<li>最后剩余的关联规则上升为知识，用于决策支持</li>
</ul>
</blockquote>
<h5>Apriori算法的优化方法</h5>
<p>由于算法是时间开销花在数据库的多次扫描上，主要的优化方法有：</p>
<ul>
<li>
数据库的划分（Partitioning）方法<br />
针对硬件限制进行优化<br />
虽然置信度和兴趣度指标可能有变化，但<strong>所有关联规则一定都会出现在各个划分中</strong><br />
<em>划分可能导致产生的关联规则数量过大，提高阈值又会损失原有的规则</em>
<ul>
<li>每一部分都能全部放在内存中进行扫描</li>
<li>最后对得到的所有频繁项集进行归并</li>
</ul>
</li>
<li>利用Hash方法筛选2阶频繁项集<br />
将每个项哈希到哈希表里，从而大量地过滤不需要的候选集</li>
<li>利用采样数据集得到可能成立的规则，再利用数据库中的剩余数据验证这些规则的正确性<br />
由于无法保证结论的正确性，此方式未必靠谱</li>
<li>
<p>减少每一遍扫描所处理的记录数</p>
<pre><code>如果一条记录不含有长度为k的频繁项集，那么这条记录也不可能含有长度为(k+1)的频繁项集
</code></pre>

<p>得到所有k阶频繁项集后，以后的每次扫描就不必再访问上述的记录，从而逐步减少被扫描的记录数</p>
</li>
</ul>
<h4>序列模式分析</h4>
<p>序列模式分析与关联规则挖掘类似，也是为了找出数据对象之间的联系，但序列模式分析法的侧重点是为了找出数据对象之间的前后因果关系<br />
被分析的对象具有前后的<strong>时序关系</strong></p>
<h3>3.分类分析</h3>
<h4>数据分类</h4>
<ul>
<li>通过分析训练数据样本，产生关于类别的精确描述  </li>
<li>这种类别通常由分类规则组成，可以用来对未来的数据进行分类和预测</li>
</ul>
<p>首先为每一个数据（记录）打上一个标记，即按标记对数据（记录）进行分类，而分类分析则是对每类数据（具有相同标记的一组记录）找出其固有的特征与规律。</p>
<h4>数据分类的步骤</h4>
<h5>建立一个模型，描述给定的数据类集或概念集，通过分析由属性描述的数据库元组来构造模型</h5>
<ul>
<li>用于建立模型的元组集称为训练数据集，其中每个元组成为训练样本<br />
训练样本的性质与待分析样本本质上没有差别，都是在实际环境中累积得到的数据</li>
<li>每个训练样本属于一个预定义的类，由类标号属性确定</li>
<li>由于给出了类标号属性，因此该步骤又成为有指导的学习<br />
需要知道分类的数量，与对应分类对人来说的意义<br />
<em>如果训练样本的类标号是未知的，则称为</em><strong><em>无指导的学习（聚类）</em></strong></li>
<li>学习模型可以用分类规则、决策树和数学公式的形式给出</li>
</ul>
<h5>使用模型对数据进行分类</h5>
<ul>
<li>评估模型的分类准确性<br />
训练数据和测试数据性质应当是一样的，但不能是两份相同的数据<br />
评价的标准包括正确性、效率、可理解性</li>
<li>对类标号未知的元组按模型进行分类</li>
</ul>
<h4>分类分析方法</h4>
<p>是一种特征归纳的方法，将每类数据共有的特性抽取以获得规律性的规则，目前有很多分析方法</p>
<ul>
<li>决策树方法</li>
<li>
贝叶斯方法  

<ul>
<li>通过前验概率和后验概率，决定某一特定样本属于标签中某一分类的概率<br />
概率的值根据训练样本提供</li>
<li>贝叶斯方法得到的结果不唯一，并且能提供相应结果的概率大小</li>
<li>贝叶斯方法计算复杂<br />
在各属性独立时，贝叶斯方法的计算可以简化</li>
</ul>
</li>
</ul>
<p>以上两种方法基于信息论，具有很好的<strong>可剪枝性</strong></p>
<ul>
<li>
人工神经网络方法
<ul>
<li>采用模拟生物神经元的方法进行分类</li>
<li>每个神经元有多个输入，提供一个输出，包含多个参数，其中有矢量</li>
<li>前一层神经元的输出作为下一层的输出</li>
<li>将训练数据输入到神经元中，如果发生错误，通过对应的反馈机制进行调整</li>
<li>
通过若干次迭代完成调整
<ul>
<li>
结束条件
<ul>
<li>正确率达到某个阈值</li>
<li>调整的比例已经很小，模型达到稳定<br />
正确率无法再有效提高</li>
<li>在可以预见的未来中无法筛选出结果<br />
此时，训练失败</li>
</ul>
</li>
</ul>
</li>
<li>神经元网络的限制并不多，并不以属性为单位进行讨论<br />
以元组为单位进行讨论</li>
<li>一旦完成训练，分类将可以以硬件的方式进行，效率非常高<br />
<em>不过形成对应的模型会非常慢</em></li>
</ul>
</li>
<li>约略集方法<br />
基于确定或不确定的边界进行的分类</li>
<li>
遗传算法  

<ul>
<li>将一般的属性和分类属性转化为一个<strong>基因</strong>（01串）<br />
对应通过一个基本数据集对分类进行预测的规则</li>
<li>最初通过随机的方式生成若干个基因</li>
<li>根据成立的比例进行优胜劣汰</li>
<li>效果最好的基因通过<strong>遗传</strong>和<strong>变异</strong>留下后代</li>
<li>每次优胜劣汰称之为一次迭代，若干次迭代后就可得到最终的分类模型</li>
</ul>
</li>
</ul>
<h5>决策树方法</h5>
<p>又称为判定树，是运用于分类的一种树结构</p>
<ul>
<li>根据对一个判定进行拆分，连接到下一个判定或结论，构成的关系就是一棵决策树</li>
<li>每个内部结点代表对某个属性的一次测试</li>
<li>每条边代表一个测试结果</li>
<li>叶结点代表某个类或者类的分布</li>
<li>最上面的结点是根结点</li>
<li>
<p>通过对信息量的计算，判断每个属性对分类所作判断的贡献大小<br />
将一个集合S拆分为S1和S2，其信息量大小有以下关系：</p>
<pre><code>I(S)≥I(S1)+I(S2)
（在属性对分类不起任何作用时取等号）

属性的信息增益A=I(S)-[I(S1)+I(S2)]
</code></pre>

<p>将贡献最优的属性放在顶层，迭代进行</p>
<ul>
<li>
中止条件
<ul>
<li>训练数据集为空</li>
<li>分类已经确定<br />
I(S)=0</li>
<li>属性已经用完，仍然无法确定地分类</li>
</ul>
</li>
</ul>
</li>
<li>由于有很好的理论支持，在<em>某种数据条件下</em>，决策树方法的效果非常好</li>
</ul>
<h3>4.聚类分析</h3>
<ul>
<li>又称集群分析，它是研究分类问题的一种多元统计方法</li>
<li>分为<strong>距离聚类</strong>和<strong>相似系数聚类</strong><br />
即定义相似程度的两种方式，不过实际上没必要严格地区分</li>
<li>没有筛选出一小部分数据，经过处理得到模型，再以此模型进行通用处理的两个阶段</li>
</ul>
<h4>与分类分析的混合使用</h4>
<p>由于聚类分析的时间复杂度与整体样本数量有关，因此可以抽样一部分数据进行聚类分析，得到结果后，对每个聚类进行概念规则挖掘，人为确定一些概念规则，再以此规则对剩余数据进行分类</p>
<ul>
<li>聚类分析输入的是没有被标记的记录，系统按照一定的规则合理的划分记录集合<br />
相当于给记录打标记，但分类标准不是用户确定的</li>
<li>然后采用分类方法对数据进行分析，并根据分析结果重新对原来的记录集合进行划分，进而再进行一次分类分析<br />
如此循环往复，直到获得满意的分析结果</li>
</ul>
<h4>主要的聚类方法</h4>
<ul>
<li>
划分方法<br />
一些场景中，划分聚类的数量k是知道的；即使不知道划分聚类的数量，也是可以以穷举的方法进行确定的（1≤k≤N）
<ul>
<li>随机地选择k个数据</li>
<li>将其它所有数据打上距离最近的标记<br />
完成一次迭代</li>
<li>根据当前聚类选择一个实际（或虚拟）的数据点<br />
具有代表性的</li>
<li>第二次迭代，根据选择的点再进行一次划分<br />
代表性的数据点继续发生变化</li>
<li>如此循环往复，直到每个数据的聚类不再发生变化为止</li>
<li>
代表数据点的选择问题
<ul>
<li>如果选择实际的数据点作为代表，选择的标准难以确定</li>
<li>如果选择虚拟的数据点作为代表，数据点又可能没有意义<br />
<strong><em>需要根据实际任务选择类型</em></strong></li>
</ul>
</li>
</ul>
</li>
<li>
层次的方法<br />
将相似程度最大的两个数据合并，以一个虚拟数据点作为其代表，重复进行计算
<ul>
<li>k值是可以不必给定的<br />
以聚类内的相似程度和聚类间的相异程度作为指标</li>
<li>没有迭代的过程，结果可能并不精确</li>
</ul>
</li>
<li>
<p>基于密度的方法<br />
定义一个<strong>密度连通</strong>的概念与阈值k、R</p>
<blockquote>
<ul>
<li>对一个数据点A，只有在其半径R范围内存在至少k个点，这个数据才是具有代表性的；如果B落在这个范围内，那么A到B是<strong>直接可达</strong>的<br />
<em>密度连通不是可逆关系</em></li>
<li>如果A与B直接可达，B与C直接可达，那么A与C<strong>间接可达</strong></li>
<li>如果A与M密度可达，A与N密度可达，那么M与N<strong>密度连通</strong></li>
<li>所有密度连通的数据落在同一个聚类中</li>
</ul>
</blockquote>
<ul>
<li>避免了划分与层次中凸多边形的问题</li>
<li>通过调整k和R可以控制聚类数量</li>
</ul>
</li>
<li>
基于网络的方法<br />
通过数量可变/不可变的，静态/动态的网格，以整个格子作为整体进行分析
<ul>
<li>难免会产生马赛克现象</li>
<li>格子的大小不好确认</li>
</ul>
</li>
<li>基于模型的方法<br />
基于概率论的方式进行分类，与决策树的方式相关</li>
<li><em>回归与预测的方法</em><br />
根据当前数据的坐标，预测一个连续、未知的数值的取值<br />
通常不认为是数据挖掘的内容，而属于数理统计范畴</li>
</ul>
<h2>五、数据挖掘的应用</h2>
<h3>1.金融业</h3>
<ul>
<li>对账户进行信用等级评估<br />
分类、聚类为主的数据挖掘方法</li>
<li>股票交易规律分析<br />
关联与时序</li>
<li>信用卡使用模式分析<br />
明确的聚类方法，会带来很多有益的信息<br />
可以定期进行非优质客户行为的筛选</li>
<li>金融市场的分析和预测</li>
</ul>
<h3>2.保险业</h3>
<ul>
<li>保险费率的确定<br />
可以从大量客户投保数据中分析并取得不同条件、不同人员、不同险种、不同时间与年龄的保险费率，使保险业主能获得合理的利润</li>
<li>险种关联分析<br />
可以分析客户在购买了某种保险后是否同时还会购买另一种保险</li>
<li>认购险种的预测<br />
可以通过数据挖掘预测新险种的客户群以及新险种的前景</li>
</ul>
<h3>3.零售业</h3>
<ul>
<li>分析顾客行为与习惯</li>
<li>分析商场销售商品的构成</li>
<li>用于商品销售预测、商品价格分析以及零售点设置布局等方面</li>
</ul>
<h3>4.科学研究</h3>
<p>数据挖掘可以从大量的、漫无边际的实验数据与历史资料中提炼出对科学规则发现有用的信息，从而起到协助科学规律发现的作用</p>
<h3>5.其它行业</h3>
<ul>
<li>医疗</li>
<li>电信</li>
<li>司法</li>
<li>故障诊断</li>
<li>……</li>
</ul>
<h3>6.应用实例</h3>
<blockquote>
<p>见ppt</p>
</blockquote>
<p>从中发现的关联规则与特征规则、分类知识可以指导今后的业务运作</p>
<h3>6.复杂类型数据源的数据挖掘</h3>
<p>数据挖掘可以运行在非结构化的数据环境上</p>
<h4>Web数据挖掘</h4>
<ul>
<li>Web内容挖掘</li>
<li>Web结构挖掘</li>
<li>Web使用记录挖掘</li>
</ul>
<h4>空间数据库挖掘</h4>
<p>空间数据库存储了大量与空间有关的矢量数据，如地图、遥感或医学图像数据</p>
<ul>
<li>没有数据挖掘前，这些数据由人工进行分析</li>
<li>医学数据可能无法自动化处理，但至少可以用于进行预处理，减少人的工作量</li>
</ul>
<h4>多媒体数据库挖掘</h4>
<ul>
<li>对图像、音频、视频的检索</li>
<li>与模式识别有关</li>
</ul>
<h4>时间序列数据挖掘</h4>
<ul>
<li>一些时间序列数据可能是实时的<br />
需要根据实时数据，<strong>准实时地</strong>提供某些建议</li>
<li>计算量和数据量间需要进行平衡</li>
</ul>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
